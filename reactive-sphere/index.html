<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>WebGPU Reactive Sphere (Tiled)</title>
    <style>
        body { margin: 0; background: #000; overflow: hidden; color: #fff; font-family: 'Roboto Mono', monospace; user-select: none; -webkit-tap-highlight-color: transparent; }
        canvas { width: 100vw; height: 100vh; display: block; touch-action: none; }

        #error-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); color: #f55; z-index: 100;
            display: none; flex-direction: column; justify-content: center; align-items: center;
            padding: 20px; box-sizing: border-box; white-space: pre-wrap; font-size: 12px;
        }

        #ui {
            position: absolute; top: 20px; left: 20px; z-index: 10;
            background: rgba(0, 0, 0, 0.6);
            padding: 15px; border-left: 3px solid #f0f;
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border-radius: 0 8px 8px 0;
            width: 280px;
            transition: transform 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
        }

        #ui-header {
            display: flex; justify-content: space-between; align-items: center;
            cursor: pointer; margin-bottom: 10px;
        }
        h1 { margin: 0; font-size: 14px; color: #f0f; text-transform: uppercase; letter-spacing: 1px; }
        #toggle-icon { font-size: 12px; color: #f0f; transform: rotate(0deg); transition: transform 0.3s; }

        #ui-content {
            overflow: hidden;
            transition: max-height 0.3s ease-out, opacity 0.3s;
            max-height: 600px; opacity: 1;
        }
        #ui.collapsed #ui-content { max-height: 0; opacity: 0; margin: 0; }
        #ui.collapsed #toggle-icon { transform: rotate(-90deg); }

        p { font-size: 10px; color: #ccc; margin-bottom: 15px; line-height: 1.4; }

        .control-group { margin-bottom: 8px; }
        label { display: flex; justify-content: space-between; font-size: 10px; color: #aaa; margin-bottom: 2px; }
        input[type=range] { width: 100%; cursor: pointer; accent-color: #f0f; height: 4px; margin: 5px 0; display: block; }

        .toggle-row { display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px; padding: 5px 0; border-bottom: 1px solid #333; }
        .toggle-label { font-size: 11px; color: #fff; font-weight: bold; }
        .toggle-switch {
            position: relative; width: 30px; height: 16px; background: #333;
            border-radius: 8px; cursor: pointer; transition: background 0.2s;
        }
        .toggle-switch.active { background: #f0f; }
        .toggle-switch::after {
            content: ''; position: absolute; top: 2px; left: 2px; width: 12px; height: 12px;
            background: #fff; border-radius: 50%; transition: left 0.2s;
        }
        .toggle-switch.active::after { left: 16px; }

        .buttons { display: flex; gap: 5px; flex-wrap: wrap; margin-top: 10px; }
        button {
            flex: 1; background: rgba(34, 34, 34, 0.8); color: #f0f; border: 1px solid #f0f;
            padding: 8px 4px; cursor: pointer; font-family: inherit; font-weight: bold;
            font-size: 10px; border-radius: 4px; white-space: nowrap;
        }
        button:hover { background: #f0f; color: #000; }
        button:active { transform: translateY(1px); }

        #minimap-guide {
            position: absolute; z-index: 5;
            border: 1px solid #444; background: rgba(0,0,0,0.5);
            pointer-events: none; display: flex; align-items: flex-end; justify-content: flex-end;
        }
        #minimap-text { color: #f0f; font-size: 10px; padding: 4px; text-shadow: 0 0 2px #000; }

        .hint {
            position: absolute; bottom: 20px; width: 100%; text-align: center;
            font-size: 10px; color: #666; pointer-events: none;
        }

        @media (min-width: 601px) {
            #minimap-guide { bottom: 20px; right: 20px; width: 200px; height: 200px; }
        }

        @media (max-width: 600px) {
            #ui {
                top: auto; left: 0; bottom: 0;
                width: 100%; box-sizing: border-box;
                border-left: none; border-top: 2px solid #f0f;
                border-radius: 16px 16px 0 0;
                padding: 12px 20px 20px 20px;
            }
            #ui-header { margin-bottom: 5px; padding: 5px 0; }
            #ui.collapsed #toggle-icon { transform: rotate(180deg); }
            #toggle-icon { transform: rotate(0deg); }
            h1 { font-size: 16px; }
            p { display: none; }
            .control-group { margin-bottom: 12px; }
            input[type=range] { height: 16px; margin: 0; }
            #minimap-guide { top: 20px; left: 20px; width: 80px; height: 80px; }
        }
    </style>
</head>
<body>
    <div id="error-overlay"></div>

    <div id="ui">
        <div id="ui-header" onclick="toggleUI()">
            <h1>Reactive Sphere</h1>
            <span id="toggle-icon">â–¼</span>
        </div>

        <div id="ui-content">
            <div class="toggle-row">
                <span class="toggle-label">AUTO PILOT</span>
                <div id="btn_auto" class="toggle-switch active"></div>
            </div>

            <p>Inner View Mode<br>Drag to look around.</p>

            <div class="control-group">
                <label><span>Feed (A)</span> <span id="v_feed">0.055</span></label>
                <input type="range" id="p_feed" min="0.01" max="0.1" step="0.0001" value="0.055">
            </div>
            <div class="control-group">
                <label><span>Kill (B)</span> <span id="v_kill">0.062</span></label>
                <input type="range" id="p_kill" min="0.045" max="0.07" step="0.0001" value="0.062">
            </div>
            <div class="control-group">
                <label><span>Depth</span> <span id="v_height">2.0</span></label>
                <input type="range" id="p_height" min="0.0" max="10.0" step="0.1" value="2.0">
            </div>
            <div class="control-group">
                <label><span>Texture Repeat</span> <span id="v_tiling">2.0</span></label>
                <input type="range" id="p_tiling" min="1.0" max="8.0" step="1.0" value="2.0">
            </div>
            <div class="control-group">
                <label><span>Sim Speed</span> <span id="v_speed">10</span></label>
                <input type="range" id="p_speed" min="1" max="50" step="1" value="10">
            </div>

            <div class="buttons">
                <button id="btn_preset1">CELLS</button>
                <button id="btn_preset2">STRIPES</button>
                <button id="btn_clear" style="border-color:#f55; color:#f55;">RESET</button>
            </div>
        </div>
    </div>

    <div id="minimap-guide"><span id="minimap-text">Source</span></div>
    <div class="hint">Drag: Look Around | Click: Touch Surface</div>

    <canvas id="canvas"></canvas>

    <script type="module">
        function showError(msg) {
            const el = document.getElementById('error-overlay');
            el.style.display = 'flex';
            el.innerText = "WebGPU Error:\n" + msg;
            console.error(msg);
        }

        const Mat4 = {
            create: () => new Float32Array([1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]),
            perspective: (out, fovy, aspect, near, far) => {
                const f = 1.0 / Math.tan(fovy / 2);
                out[0] = f / aspect; out[1] = 0; out[2] = 0; out[3] = 0;
                out[4] = 0; out[5] = f; out[6] = 0; out[7] = 0;
                out[8] = 0; out[9] = 0; out[10] = far / (near - far); out[11] = -1;
                out[12] = 0; out[13] = 0; out[14] = (near * far) / (near - far); out[15] = 0;
                return out;
            },
            lookAt: (out, eye, center, up) => {
                let x0, x1, x2, y0, y1, y2, z0, z1, z2, len;
                let eyex = eye[0], eyey = eye[1], eyez = eye[2];
                let upx = up[0], upy = up[1], upz = up[2];
                let centerx = center[0], centery = center[1], centerz = center[2];
                z0 = eyex - centerx; z1 = eyey - centery; z2 = eyez - centerz;
                len = 1 / Math.hypot(z0, z1, z2); z0 *= len; z1 *= len; z2 *= len;
                x0 = upy * z2 - upz * z1; x1 = upz * z0 - upx * z2; x2 = upx * z1 - upy * z0;
                len = Math.hypot(x0, x1, x2);
                if (!len) { x0 = 0; x1 = 0; x2 = 0; } else { len = 1 / len; x0 *= len; x1 *= len; x2 *= len; }
                y0 = z1 * x2 - z2 * x1; y1 = z2 * x0 - z0 * x2; y2 = z0 * x1 - z1 * x0;
                len = Math.hypot(y0, y1, y2);
                if (!len) { y0 = 0; y1 = 0; y2 = 0; } else { len = 1 / len; y0 *= len; y1 *= len; y2 *= len; }
                out[0] = x0; out[1] = y0; out[2] = z0; out[3] = 0;
                out[4] = x1; out[5] = y1; out[6] = z1; out[7] = 0;
                out[8] = x2; out[9] = y2; out[10] = z2; out[11] = 0;
                out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
                out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
                out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
                out[15] = 1;
                return out;
            },
            multiply: (out, a, b) => {
                let a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
                let a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
                let a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
                let a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
                let b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
                out[0] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
                out[1] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
                out[2] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
                out[3] = b0*a03 + b1*a13 + b2*a23 + b3*a33;
                b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];
                out[4] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
                out[5] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
                out[6] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
                out[7] = b0*a03 + b1*a13 + b2*a23 + b3*a33;
                b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];
                out[8] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
                out[9] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
                out[10] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
                out[11] = b0*a03 + b1*a13 + b2*a23 + b3*a33;
                b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];
                out[12] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
                out[13] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
                out[14] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
                out[15] = b0*a03 + b1*a13 + b2*a23 + b3*a33;
                return out;
            },
            invert: (out, a) => {
                let a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
                let a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
                let a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
                let a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
                let b00 = a00 * a11 - a01 * a10, b01 = a00 * a12 - a02 * a10, b02 = a00 * a13 - a03 * a10;
                let b03 = a01 * a12 - a02 * a11, b04 = a01 * a13 - a03 * a11, b05 = a02 * a13 - a03 * a12;
                let b06 = a20 * a31 - a21 * a30, b07 = a20 * a32 - a22 * a30, b08 = a20 * a33 - a23 * a30;
                let b09 = a21 * a32 - a22 * a31, b10 = a21 * a33 - a23 * a31, b11 = a22 * a33 - a23 * a32;
                let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
                if (!det) return null;
                det = 1.0 / det;
                out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
                out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
                out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
                out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
                out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
                out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
                out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
                out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
                out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
                out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
                out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
                out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
                out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
                out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
                out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
                out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
                return out;
            }
        };

        window.toggleUI = () => {
            document.getElementById('ui').classList.toggle('collapsed');
        };

        const SIM_SIZE = 256;
        const MESH_RES = 256;

        // Shader with Periodic Boundary & Tiling
        const shaderCode = `
        struct Uniforms {
            params: vec4<f32>, // x:feed, y:kill, z:dt, w:brushVal
            mouse: vec4<f32>,  // x, y, autoMode, time
            dims: vec2<f32>,
        };
        @group(0) @binding(0) var<uniform> u: Uniforms;

        @group(0) @binding(1) var texIn: texture_2d<f32>;
        @group(0) @binding(2) var texOut: texture_storage_2d<rgba16float, write>;

        // Periodic (Torus) boundary fetch helper
        fn getVal(base: vec2<i32>, offset: vec2<i32>, w: i32, h: i32) -> vec4<f32> {
            // ((x % n) + n) % n logic for wrapping negative values correctly
            let x = ((base.x + offset.x) % w + w) % w;
            let y = ((base.y + offset.y) % h + h) % h;
            return textureLoad(texIn, vec2<i32>(x, y), 0);
        }

        @compute @workgroup_size(16, 16)
        fn simMain(@builtin(global_invocation_id) id: vec3<u32>) {
            let w = i32(u.dims.x);
            let h = i32(u.dims.y);
            if (id.x >= u32(w) || id.y >= u32(h)) { return; }
            let pos = vec2<i32>(id.xy);
            let uv = (vec2<f32>(pos) + 0.5) / u.dims;

            let center = textureLoad(texIn, pos, 0);
            var lap = vec4<f32>(0.0);

            // Full Torus Wrapping for Neighbors
            lap += getVal(pos, vec2<i32>(1, 0), w, h) * 0.2;
            lap += getVal(pos, vec2<i32>(-1, 0), w, h) * 0.2;
            lap += getVal(pos, vec2<i32>(0, 1), w, h) * 0.2;
            lap += getVal(pos, vec2<i32>(0, -1), w, h) * 0.2;

            lap += getVal(pos, vec2<i32>(1, 1), w, h) * 0.05;
            lap += getVal(pos, vec2<i32>(1, -1), w, h) * 0.05;
            lap += getVal(pos, vec2<i32>(-1, 1), w, h) * 0.05;
            lap += getVal(pos, vec2<i32>(-1, -1), w, h) * 0.05;

            lap += center * -1.0;

            let valA = center.r;
            let valB = center.g;

            var feed = u.params.x;
            var kill = u.params.y;

            if (u.mouse.z > 0.5) {
                let time = u.mouse.w;
                let spatial = sin(uv.x * 6.0 + time * 0.5) * 0.5 + 0.5;
                let t_feed = sin(time * 0.2) * 0.015;
                let t_kill = cos(time * 0.3) * 0.005;
                feed = 0.04 + t_feed + spatial * 0.02;
                kill = 0.060 + t_kill + spatial * 0.002;
            }

            let dt = 1.0;
            let reaction = valA * valB * valB;
            var newA = valA + (1.0 * lap.r - reaction + feed * (1.0 - valA)) * dt;
            var newB = valB + (0.5 * lap.g + reaction - (kill + feed) * valB) * dt;

            // Interaction - Wrap Logic for Mouse
            // Simple distance check in Torus space is complex, using Euclidean for now.
            // But since texture is tiled visually, interaction should ideally tile too.
            // For now, simple local interaction is fine.
            if (u.params.w > 0.5) {
                if (u.mouse.x >= 0.0) {
                    let mouseDist = distance(vec2<f32>(pos), u.mouse.xy);
                    if (mouseDist < 12.0) { newB = 0.9; }
                }
            }

            if (u.mouse.z > 0.5) {
                let noise = fract(sin(dot(vec2<f32>(pos) + u.mouse.w, vec2<f32>(12.9898, 78.233))) * 43758.5453);
                if (noise > 0.99995) { newB = 0.9; }
            }

            textureStore(texOut, pos, vec4<f32>(clamp(newA,0.0,1.0), clamp(newB,0.0,1.0), 0.0, 1.0));
        }

        struct RenderUniforms {
            viewProj: mat4x4<f32>,
            heightScale: f32,
            time: f32,
            tiling: f32, // Added tiling uniform
        };
        @group(0) @binding(0) var<uniform> ru: RenderUniforms;
        @group(0) @binding(1) var simTex: texture_2d<f32>;
        @group(0) @binding(2) var samp: sampler;

        struct VSOut {
            @builtin(position) pos: vec4<f32>,
            @location(0) uv: vec2<f32>,
            @location(1) height: f32,
        };

        @vertex
        fn vsMain(@builtin(vertex_index) idx: u32) -> VSOut {
            let width = ${MESH_RES}.0;
            let x = f32(idx % (${MESH_RES} + 1));
            let z = f32(idx / (${MESH_RES} + 1));

            let u = x / width;
            let v = z / width;

            // Sphere generation (UV Sphere)
            let PI = 3.14159265;
            let theta = u * 2.0 * PI;
            let phi = v * PI;

            // HUGE RADIUS to push walls away
            let radius = 40.0;
            let px = radius * sin(phi) * cos(theta);
            let py = radius * cos(phi);
            let pz = radius * sin(phi) * sin(theta);

            let rawPos = vec3<f32>(px, py, pz);
            let normal = normalize(rawPos);

            // Tiling UV for texture sampling
            let tiledUV = vec2<f32>(u, v) * ru.tiling;

            let simVal = textureSampleLevel(simTex, samp, tiledUV, 0.0).g;

            // Displace INWARDS
            let displace = simVal * ru.heightScale;
            let finalPos = rawPos - normal * displace;

            var out: VSOut;
            out.pos = ru.viewProj * vec4<f32>(finalPos, 1.0);
            out.uv = tiledUV; // Pass tiled UV to fragment for consistent look
            out.height = simVal;
            return out;
        }

        @fragment
        fn fsMain(in: VSOut) -> @location(0) vec4<f32> {
            let h = in.height;
            var col = vec3<f32>(0.01, 0.01, 0.02);

            // Grid lines based on Tiled UV
            let grid = (fract(in.uv.x * 20.0) < 0.05 || fract(in.uv.y * 20.0) < 0.05);
            if (grid) { col += vec3<f32>(0.03); }

            let glow = vec3<f32>(0.5, 0.0, 1.0);
            let peak = vec3<f32>(0.0, 1.0, 1.0);

            let t = smoothstep(0.15, 0.5, h);
            col = mix(col, glow, t);

            let t2 = smoothstep(0.45, 0.7, h);
            col = mix(col, peak, t2);

            col *= 0.5 + h * 2.5;
            return vec4<f32>(col, 1.0);
        }

        @vertex
        fn vsMini(@builtin(vertex_index) idx: u32) -> VSOut {
            var p = array<vec2<f32>, 4>(vec2<f32>(-1.0,-1.0), vec2<f32>(1.0,-1.0), vec2<f32>(-1.0,1.0), vec2<f32>(1.0,1.0));
            var out: VSOut;
            out.pos = vec4<f32>(p[idx], 0.0, 1.0);
            out.uv = p[idx] * 0.5 + 0.5; out.uv.y = 1.0 - out.uv.y;
            return out;
        }

        @fragment
        fn fsMini(in: VSOut) -> @location(0) vec4<f32> {
            let val = textureSample(simTex, samp, in.uv).g;
            return vec4<f32>(val, val, val, 1.0);
        }
        `;

        async function init() {
            if (!navigator.gpu) { showError("WebGPU not supported on this browser."); return; }

            try {
                const adapter = await navigator.gpu.requestAdapter();
                if (!adapter) { showError("No GPU adapter found."); return; }
                const device = await adapter.requestDevice();

                device.pushErrorScope('validation');

                const canvas = document.getElementById('canvas');
                const context = canvas.getContext('webgpu');
                const format = navigator.gpu.getPreferredCanvasFormat();
                context.configure({ device, format, alphaMode: 'opaque' });

                const module = device.createShaderModule({ code: shaderCode });

                const createTex = () => device.createTexture({
                    size: [SIM_SIZE, SIM_SIZE], format: 'rgba16float',
                    usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.COPY_DST
                });
                let texA = createTex();
                let texB = createTex();

                {
                    const data = new Float32Array(SIM_SIZE * SIM_SIZE * 4);
                    for (let i = 0; i < SIM_SIZE * SIM_SIZE; i++) {
                        data[i*4] = 1.0; data[i*4+1] = 0.0;
                        if (Math.random() < 0.005) data[i*4+1] = 1.0;
                    }
                    device.queue.writeTexture({ texture: texA }, data, { bytesPerRow: SIM_SIZE*16 }, [SIM_SIZE, SIM_SIZE]);
                }

                const simPipeline = device.createComputePipeline({
                    layout: 'auto', compute: { module, entryPoint: 'simMain' }
                });

                const indices = [];
                for (let z = 0; z < MESH_RES; z++) {
                    for (let x = 0; x < MESH_RES; x++) {
                        let i = z * (MESH_RES + 1) + x;
                        indices.push(i, i + MESH_RES + 1, i + 1, i + 1, i + MESH_RES + 1, i + MESH_RES + 2);
                    }
                }
                const iBuf = device.createBuffer({ size: indices.length * 4, usage: GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST });
                device.queue.writeBuffer(iBuf, 0, new Uint32Array(indices));

                const renderPipeline = device.createRenderPipeline({
                    layout: 'auto',
                    vertex: { module, entryPoint: 'vsMain' },
                    fragment: { module, entryPoint: 'fsMain', targets: [{ format }] },
                    primitive: { topology: 'triangle-list', cullMode: 'none' },
                    depthStencil: { depthWriteEnabled: true, depthCompare: 'less', format: 'depth24plus' }
                });

                const miniPipeline = device.createRenderPipeline({
                    layout: 'auto',
                    vertex: { module, entryPoint: 'vsMini' },
                    fragment: { module, entryPoint: 'fsMini', targets: [{ format }] },
                    primitive: { topology: 'triangle-strip' },
                    depthStencil: { format: 'depth24plus', depthWriteEnabled: false, depthCompare: 'always' }
                });

                let depthTex = null;
                const resizeDepth = () => {
                    if(depthTex) depthTex.destroy();
                    const w = Math.max(1, canvas.width);
                    const h = Math.max(1, canvas.height);
                    depthTex = device.createTexture({
                        size: [w, h], format: 'depth24plus',
                        usage: GPUTextureUsage.RENDER_ATTACHMENT
                    });
                };
                window.addEventListener('resize', resizeDepth);
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                resizeDepth();

                const simUBuf = device.createBuffer({ size: 48, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
                // Render Uniforms expanded for tiling (mat4 + float + float + float + padding)
                // 16 + 1 + 1 + 1 = 19 floats -> 20 floats (80 bytes) aligned
                const renderUBuf = device.createBuffer({ size: 80, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });

                // REPEAT Sampler for Tiling
                const sampler = device.createSampler({ magFilter: 'linear', minFilter: 'linear', addressModeU: 'repeat', addressModeV: 'repeat' });

                const params = { feed: 0.055, kill: 0.062, speed: 10, height: 2.0, brush: 0, mouseX: -1, mouseY: -1, auto: 1, tiling: 2.0 };

                const cam = {
                    rotX: 0.0, rotY: 0.0,
                    isDragging: false, lastX: 0, lastY: 0
                };

                const autoBtn = document.getElementById('btn_auto');
                autoBtn.addEventListener('click', () => {
                    params.auto = params.auto ? 0 : 1;
                    autoBtn.classList.toggle('active', !!params.auto);
                });

                const bindRange = (id, k, dispId) => {
                    const el = document.getElementById(id);
                    el.addEventListener('input', e => {
                        params[k] = parseFloat(e.target.value);
                        if (k === 'feed' || k === 'kill') { params.auto = 0; autoBtn.classList.remove('active'); }
                        if(dispId) document.getElementById(dispId).innerText = params[k];
                    });
                };
                bindRange('p_feed', 'feed', 'v_feed');
                bindRange('p_kill', 'kill', 'v_kill');
                bindRange('p_height', 'height', 'v_height');
                bindRange('p_speed', 'speed', 'v_speed');
                bindRange('p_tiling', 'tiling', 'v_tiling');

                document.getElementById('btn_clear').addEventListener('click', () => {
                    const data = new Float32Array(SIM_SIZE*SIM_SIZE*4).map((_,i) => (i%4===0?1:0));
                    device.queue.writeTexture({ texture: texA }, data, { bytesPerRow: SIM_SIZE*16 }, [SIM_SIZE, SIM_SIZE]);
                    device.queue.writeTexture({ texture: texB }, data, { bytesPerRow: SIM_SIZE*16 }, [SIM_SIZE, SIM_SIZE]);
                });
                const setPreset = (f, k) => {
                    params.feed = f; params.kill = k;
                    params.auto = 0; autoBtn.classList.remove('active');
                    document.getElementById('p_feed').value = f; document.getElementById('v_feed').innerText = f;
                    document.getElementById('p_kill').value = k; document.getElementById('v_kill').innerText = k;
                };
                document.getElementById('btn_preset1').addEventListener('click', () => setPreset(0.035, 0.060));
                document.getElementById('btn_preset2').addEventListener('click', () => setPreset(0.055, 0.062));

                const getSphereUV = (clientX, clientY, viewProj) => {
                    const rect = canvas.getBoundingClientRect();
                    const x = ((clientX - rect.left) / rect.width) * 2 - 1;
                    const y = -((clientY - rect.top) / rect.height) * 2 + 1;
                    const invVP = Mat4.create(); Mat4.invert(invVP, viewProj);
                    const n = [x, y, 0, 1], f = [x, y, 1, 1];
                    const tn = new Float32Array(4), tf = new Float32Array(4);
                    Mat4.multiply(tn, invVP, n); Mat4.multiply(tf, invVP, f);
                    const pn = [tn[0]/tn[3], tn[1]/tn[3], tn[2]/tn[3]];
                    const pf = [tf[0]/tf[3], tf[1]/tf[3], tf[2]/tf[3]];
                    const dir = [pf[0]-pn[0], pf[1]-pn[1], pf[2]-pn[2]];

                    const len = Math.hypot(dir[0], dir[1], dir[2]);
                    const dx = dir[0]/len; const dy = dir[1]/len; const dz = dir[2]/len;

                    // Simple logic: Cam at (0,0,0). Ray D.
                    // Sphere radius 40. P = 40 * D.
                    // We map D vector to UV.

                    const phi = Math.acos(dy);
                    const theta = Math.atan2(dz, dx);

                    let u = theta / (2.0 * Math.PI);
                    if (u < 0) u += 1.0;
                    let v = phi / Math.PI;

                    // Adjust UV for tiling logic interaction?
                    // If we tile visual, interaction should map to the primary tile?
                    // Or repeat interaction across tiles?
                    // To keep it simple: Map to 0..1 space. Interaction happens once in texture space.
                    // Visual is tiled. So you might touch a ghost tile, and real effect happens on main tile.
                    // To support touching ANY tile:
                    // u = (u * tiling) % 1.0;

                    u = (u * params.tiling) % 1.0;
                    v = (v * params.tiling) % 1.0;

                    return [u, v];
                };

                const updateInteraction = (e, isDraw, viewProj) => {
                    if (isDraw) {
                        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                        const uv = getSphereUV(clientX, clientY, viewProj);
                        params.mouseX = uv[0] * SIM_SIZE;
                        params.mouseY = uv[1] * SIM_SIZE;
                        params.brush = 1;
                    }
                };

                canvas.addEventListener('mousedown', e => {
                    if (e.button === 0) params.isDrawing = true;
                    if (e.button === 2) { cam.isDragging = true; cam.lastX = e.clientX; cam.lastY = e.clientY; }
                });
                canvas.addEventListener('mousemove', e => {
                    if (cam.isDragging) {
                        const dx = e.clientX - cam.lastX;
                        const dy = e.clientY - cam.lastY;
                        cam.rotX -= dx * 0.005;
                        cam.rotY -= dy * 0.005;
                        cam.rotY = Math.max(-Math.PI/2 + 0.1, Math.min(Math.PI/2 - 0.1, cam.rotY));
                        cam.lastX = e.clientX;
                        cam.lastY = e.clientY;
                    }
                });
                window.addEventListener('mouseup', () => { params.isDrawing = false; params.brush = 0; cam.isDragging = false; });
                canvas.addEventListener('touchstart', e => { if(e.touches.length===1) params.isDrawing = true; e.preventDefault(); }, {passive:false});
                window.addEventListener('touchend', () => { params.isDrawing = false; params.brush = 0; });
                canvas.addEventListener('contextmenu', e => e.preventDefault());

                const createSimBG = (inT, outT) => device.createBindGroup({
                    layout: simPipeline.getBindGroupLayout(0),
                    entries: [
                        { binding: 0, resource: { buffer: simUBuf } },
                        { binding: 1, resource: inT.createView() },
                        { binding: 2, resource: outT.createView() }
                    ]
                });

                let lastMouseEvt = null;
                canvas.addEventListener('mousemove', e => { lastMouseEvt = e; });
                canvas.addEventListener('touchmove', e => { lastMouseEvt = e; });

                function frame() {
                    device.pushErrorScope('validation');

                    canvas.width = window.innerWidth; canvas.height = window.innerHeight;
                    if (canvas.width !== depthTex.width || canvas.height !== depthTex.height) resizeDepth();

                    const aspect = canvas.width / canvas.height;
                    const proj = Mat4.perspective(Mat4.create(), Math.PI/3, aspect, 0.1, 100.0);
                    // Camera at Center (0,0,0) looking out. Direction based on rotX/Y.
                    const cx = Math.sin(cam.rotX) * Math.cos(cam.rotY);
                    const cy = Math.sin(cam.rotY);
                    const cz = Math.cos(cam.rotX) * Math.cos(cam.rotY);
                    const view = Mat4.lookAt(Mat4.create(), [0,0,0], [cx, cy, cz], [0,1,0]);
                    const vp = Mat4.multiply(Mat4.create(), proj, view);

                    if (params.isDrawing && lastMouseEvt) {
                        updateInteraction(lastMouseEvt, true, vp);
                    } else {
                        params.brush = 0;
                    }

                    const time = performance.now() / 1000;
                    if (params.auto) {
                        document.getElementById('p_feed').value = 0.04 + Math.sin(time*0.2)*0.015;
                        document.getElementById('p_kill').value = 0.06 + Math.cos(time*0.3)*0.005;
                        document.getElementById('v_feed').innerText = "AUTO";
                        document.getElementById('v_kill').innerText = "AUTO";
                    }

                    device.queue.writeBuffer(simUBuf, 0, new Float32Array([params.feed, params.kill, 1.0, params.brush, params.mouseX, params.mouseY, params.auto, time, SIM_SIZE, SIM_SIZE, 0, 0]));

                    const enc = device.createCommandEncoder();

                    for (let i = 0; i < params.speed; i++) {
                        const pass = enc.beginComputePass();
                        pass.setPipeline(simPipeline);
                        pass.setBindGroup(0, createSimBG(texA, texB));
                        pass.dispatchWorkgroups(SIM_SIZE/16, SIM_SIZE/16);
                        pass.end();
                        [texA, texB] = [texB, texA];
                    }

                    const rData = new Float32Array(20);
                    rData.set(vp, 0);
                    rData[16] = params.height;
                    rData[17] = time;
                    rData[18] = params.tiling;
                    device.queue.writeBuffer(renderUBuf, 0, rData);

                    const pass = enc.beginRenderPass({
                        colorAttachments: [{ view: context.getCurrentTexture().createView(), loadOp: 'clear', clearValue: {r:0,g:0,b:0,a:1}, storeOp: 'store' }],
                        depthStencilAttachment: { view: depthTex.createView(), depthLoadOp: 'clear', depthClearValue: 1.0, depthStoreOp: 'store' }
                    });

                    pass.setPipeline(renderPipeline);
                    pass.setBindGroup(0, device.createBindGroup({
                        layout: renderPipeline.getBindGroupLayout(0),
                        entries: [
                            { binding: 0, resource: { buffer: renderUBuf } },
                            { binding: 1, resource: texA.createView() },
                            { binding: 2, resource: sampler }
                        ]
                    }));
                    pass.setIndexBuffer(iBuf, 'uint32');
                    pass.drawIndexed(indices.length);

                    // Minimap
                    const guide = document.getElementById('minimap-guide').getBoundingClientRect();
                    const vpY = canvas.height - guide.bottom;
                    pass.setViewport(guide.left, vpY, guide.width, guide.height, 0, 1);

                    pass.setPipeline(miniPipeline);
                    pass.setBindGroup(0, device.createBindGroup({
                        layout: miniPipeline.getBindGroupLayout(0),
                        entries: [
                            { binding: 1, resource: texA.createView() },
                            { binding: 2, resource: sampler }
                        ]
                    }));
                    pass.draw(4);
                    pass.end();

                    device.queue.submit([enc.finish()]);

                    device.popErrorScope().then(err => {
                        if(err) showError(err.message);
                    });

                    requestAnimationFrame(frame);
                }

                requestAnimationFrame(frame);

            } catch (e) {
                showError(e.message);
            }
        }
        init();
    </script>
</body>
</html>
