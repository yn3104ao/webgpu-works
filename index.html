<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>WebGPU F1 3D CFD - Bulletproof</title>
    <style>
        body { margin: 0; background: #000; overflow: hidden; color: #fff; font-family: 'Roboto Mono', monospace; user-select: none; }
        canvas { width: 100vw; height: 100vh; display: block; }

        #controls {
            position: absolute; top: 20px; left: 20px; z-index: 10;
            background: rgba(0, 0, 0, 0.85);
            padding: 15px; border-left: 3px solid #f0f;
            width: 280px;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            border-radius: 0 8px 8px 0;
        }
        h1 { margin: 0 0 5px 0; font-size: 16px; color: #f0f; text-transform: uppercase; letter-spacing: 1px; }
        .subtitle { font-size: 10px; color: #888; margin-bottom: 15px; }
        .row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; font-size: 11px; color: #ccc; }
        input[type=range] { width: 120px; cursor: pointer; accent-color: #f0f; }
        button {
            width: 100%; background: #222; color: #f0f; border: 1px solid #f0f;
            padding: 8px; cursor: pointer; font-family: inherit; font-weight: bold;
            margin-top: 5px; transition: all 0.1s;
        }
        button:hover { background: #f0f; color: #000; }
        button.active { background: #f0f; color: #000; box-shadow: 0 0 10px #f0f; }

        .val { color: #fff; width: 35px; text-align: right; }

        .legend { position: absolute; bottom: 20px; left: 20px; font-size: 11px; pointer-events: none; }
        .legend-item { display: flex; align-items: center; margin-top: 5px; text-shadow: 0 0 2px #000; }
        .box { width: 10px; height: 10px; margin-right: 8px; border: 1px solid #fff; }
        .purple { background: #f0f; box-shadow: 0 0 8px #f0f; }
        .blue { background: #0af; opacity: 0.6; }

        .key-hint {
            margin-top: 15px; font-size: 10px; color: #aaa; line-height: 1.6;
            border-top: 1px solid #333; padding-top: 10px;
        }
        .k { color: #f0f; font-weight: bold; }

        /* Gizmo Canvas */
        #gizmo {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 100px;
            height: 100px;
            z-index: 20;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="controls">
        <h1>F1 Aero Lab</h1>
        <div class="subtitle">Grid: 128x48x48 | Stabilized</div>

        <div class="row">
            <span>Car Position X</span>
            <input type="range" id="p_pos" min="-1.5" max="0.5" step="0.1" value="-1.0">
            <span id="v_pos" class="val">-1.0</span>
        </div>
        <div class="row">
            <span>Substeps</span>
            <input type="range" id="p_sub" min="1" max="50" step="1" value="20">
            <span id="v_sub" class="val">20</span>
        </div>
        <div class="row">
            <span>Time Step</span>
            <input type="range" id="p_dt" min="0.001" max="0.010" step="0.001" value="0.005">
            <span id="v_dt" class="val">.005</span>
        </div>
        <div class="row">
            <span>Wind Speed</span>
            <input type="range" id="p_speed" min="0" max="4.0" step="0.1" value="1.6">
            <span id="v_speed" class="val">1.6</span>
        </div>
        <div class="row">
            <span>Flow Decay</span>
            <input type="range" id="p_decay" min="0.95" max="1.0" step="0.001" value="0.998">
            <span id="v_decay" class="val">.998</span>
        </div>
        <div class="row">
            <span>Suction Viz</span>
            <input type="range" id="p_glow" min="0.001" max="0.1" step="0.001" value="0.001">
            <span id="v_glow" class="val">.001</span>
        </div>

        <!-- DRS Toggle Button -->
        <button id="btn_drs">DRS: CLOSED</button>
        <button id="btn_reset">RESET SIMULATION</button>

        <div class="key-hint">
            <span class="k">L-Drag</span>: Rotate Cam<br>
            <span class="k">WASD</span>: Move Cam Target<br>
            <span class="k">Q</span>: Up / <span class="k">E</span>: Down<br>
            <span class="k">Wheel</span>: Zoom<br>
            <span class="k">Shift</span>: Boost Speed
        </div>
    </div>

    <div class="legend">
        <div class="legend-item"><div class="box purple"></div> <span>Low Pressure (Downforce)</span></div>
        <div class="legend-item"><div class="box blue"></div> <span>Wake / Tow</span></div>
    </div>

    <canvas id="canvas"></canvas>
    <canvas id="gizmo" width="100" height="100"></canvas>

    <script type="module">
        // --- Math Lib ---
        const Mat4 = {
            create: () => new Float32Array([1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]),
            perspective: (out, fovy, aspect, near, far) => {
                const f = 1.0 / Math.tan(fovy / 2), nf = 1 / (near - far);
                out[0] = f / aspect; out[1] = 0; out[2] = 0; out[3] = 0;
                out[4] = 0; out[5] = f; out[6] = 0; out[7] = 0;
                out[8] = 0; out[9] = 0; out[10] = (far + near) * nf; out[11] = -1;
                out[12] = 0; out[13] = 0; out[14] = (2 * far * near) * nf; out[15] = 0;
                return out;
            },
            lookAt: (out, eye, center, up) => {
                let x0, x1, x2, y0, y1, y2, z0, z1, z2, len;
                let eyex = eye[0], eyey = eye[1], eyez = eye[2];
                let upx = up[0], upy = up[1], upz = up[2];
                let centerx = center[0], centery = center[1], centerz = center[2];
                z0 = eyex - centerx; z1 = eyey - centery; z2 = eyez - centerz;
                len = 1 / Math.hypot(z0, z1, z2); z0 *= len; z1 *= len; z2 *= len;
                x0 = upy * z2 - upz * z1; x1 = upz * z0 - upx * z2; x2 = upx * z1 - upy * z0;
                len = Math.hypot(x0, x1, x2);
                if (!len) { x0 = 0; x1 = 0; x2 = 0; } else { len = 1 / len; x0 *= len; x1 *= len; x2 *= len; }
                y0 = z1 * x2 - z2 * x1; y1 = z2 * x0 - z0 * x2; y2 = z0 * x1 - z1 * x0;
                len = Math.hypot(y0, y1, y2);
                if (!len) { y0 = 0; y1 = 0; y2 = 0; } else { len = 1 / len; y0 *= len; y1 *= len; y2 *= len; }
                out[0] = x0; out[1] = y0; out[2] = z0; out[3] = 0;
                out[4] = x1; out[5] = y1; out[6] = z1; out[7] = 0;
                out[8] = x2; out[9] = y2; out[10] = z2; out[11] = 0;
                out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
                out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
                out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
                out[15] = 1;
                return out;
            },
            multiply: (out, a, b) => {
                let a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
                let a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
                let a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
                let a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
                let b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
                out[0] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
                out[1] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
                out[2] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
                out[3] = b0*a03 + b1*a13 + b2*a23 + b3*a33;
                b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];
                out[4] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
                out[5] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
                out[6] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
                out[7] = b0*a03 + b1*a13 + b2*a23 + b3*a33;
                b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];
                out[8] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
                out[9] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
                out[10] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
                out[11] = b0*a03 + b1*a13 + b2*a23 + b3*a33;
                b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];
                out[12] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
                out[13] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
                out[14] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
                out[15] = b0*a03 + b1*a13 + b2*a23 + b3*a33;
                return out;
            },
            invert: (out, a) => {
                let a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
                let a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
                let a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
                let a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
                let b00 = a00 * a11 - a01 * a10, b01 = a00 * a12 - a02 * a10, b02 = a00 * a13 - a03 * a10;
                let b03 = a01 * a12 - a02 * a11, b04 = a01 * a13 - a03 * a11, b05 = a02 * a13 - a03 * a12;
                let b06 = a20 * a31 - a21 * a30, b07 = a20 * a32 - a22 * a30, b08 = a20 * a33 - a23 * a30;
                let b09 = a21 * a32 - a22 * a31, b10 = a21 * a33 - a23 * a31, b11 = a22 * a33 - a23 * a32;
                let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
                if (!det) return null;
                det = 1.0 / det;
                out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
                out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
                out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
                out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
                out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
                out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
                out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
                out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
                out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
                out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
                out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
                out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
                out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
                out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
                out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
                out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
                return out;
            }
        };

        const SIZE = [128, 48, 48];
        const WORKGROUP = [8, 4, 4];

        // Shader Code
        const shaderCode = `
        struct Uniforms {
            res: vec4<f32>,
            params: vec4<f32>, // x:speed, y:dt, z:decay, w:glow_thresh
            camPos: vec4<f32>,
            viewProj: mat4x4<f32>,
            invViewProj: mat4x4<f32>,
        };
        @group(0) @binding(0) var<uniform> u: Uniforms;

        @group(0) @binding(1) var velIn: texture_3d<f32>;
        @group(0) @binding(2) var velOut: texture_storage_3d<rgba16float, write>;
        @group(0) @binding(3) var denIn: texture_3d<f32>;
        @group(0) @binding(4) var denOut: texture_storage_3d<rgba16float, write>;
        @group(0) @binding(5) var presIn: texture_3d<f32>;
        @group(0) @binding(6) var presOut: texture_storage_3d<r32float, write>;
        @group(0) @binding(7) var div: texture_storage_3d<r32float, write>;
        @group(0) @binding(8) var divIn: texture_3d<f32>;
        @group(0) @binding(9) var samplerLin: sampler;
        @group(0) @binding(10) var obsTex: texture_3d<f32>;

        fn getUV(id: vec3<u32>) -> vec3<f32> { return (vec3<f32>(id) + 0.5) / u.res.xyz; }

        // --- Advection ---
        @compute @workgroup_size(8, 4, 4)
        fn advectMain(@builtin(global_invocation_id) id: vec3<u32>) {
            if (any(id >= vec3<u32>(u.res.xyz))) { return; }
            let pos = vec3<i32>(id);
            let obs = textureLoad(obsTex, pos, 0).r;
            if (obs > 0.5) {
                textureStore(velOut, pos, vec4<f32>(0.0));
                textureStore(denOut, pos, vec4<f32>(0.0));
                return;
            }

            let v = textureLoad(velIn, pos, 0).xyz;
            // Backtrace scale
            let srcPos = vec3<f32>(pos) - v * u.params.y * 30.0;
            let uv = (srcPos + 0.5) / u.res.xyz;

            let decay = u.params.z;
            let newVel = textureSampleLevel(velIn, samplerLin, uv, 0.0).xyz;
            textureStore(velOut, pos, vec4<f32>(newVel * decay, 0.0));

            let newDen = textureSampleLevel(denIn, samplerLin, uv, 0.0).r;
            textureStore(denOut, pos, vec4<f32>(newDen * decay, 0.0, 0.0, 0.0));
        }

        // --- Force & Inflow ---
        @compute @workgroup_size(8, 4, 4)
        fn forceMain(@builtin(global_invocation_id) id: vec3<u32>) {
            if (any(id >= vec3<u32>(u.res.xyz))) { return; }
            let pos = vec3<i32>(id);
            let obs = textureLoad(obsTex, pos, 0).r;
            if (obs > 0.5) { return; }

            var v = textureLoad(velIn, pos, 0).xyz;
            var d = textureLoad(denIn, pos, 0).r;

            let speed = u.params.x; // Wind Speed
            let dt = u.params.y;

            // Drag Force
            v.x += 0.2 * speed * dt;

            // SAFETY CLAMP: Prevent explosion
            // If velocity is too high, clamp it.
            if (length(v) > 4.0) { v = normalize(v) * 4.0; }

            // Inflow Injection (Front)
            // Left Wall Inflow
            if (pos.x < 4 && pos.y > 2 && pos.y < 46 && pos.z > 2 && pos.z < 46) {
                let injectionVel = vec3<f32>(speed * 3.0, 0.0, 0.0);
                v = mix(v, injectionVel, 0.2);

                let t = u.camPos.w; // Time
                if (speed > 0.1) {
                    if (pos.y < 8 && (pos.z % 4 == 0)) { d = mix(d, 1.0, 0.1); }
                    if (pos.y > 10 && sin(f32(pos.y)*0.3 + t*5.0)*cos(f32(pos.z)*0.3) > 0.5) {
                        d = mix(d, 0.8, 0.1);
                    }
                }
            }

            textureStore(velOut, pos, vec4<f32>(v, 0.0));
            textureStore(denOut, pos, vec4<f32>(d, 0.0, 0.0, 0.0));
        }

        // --- Divergence ---
        @compute @workgroup_size(8, 4, 4)
        fn divMain(@builtin(global_invocation_id) id: vec3<u32>) {
            if (any(id >= vec3<u32>(u.res.xyz))) { return; }
            let pos = vec3<i32>(id);
            let L = textureLoad(velIn, pos + vec3<i32>(-1,0,0), 0).x;
            let R = textureLoad(velIn, pos + vec3<i32>( 1,0,0), 0).x;
            let B = textureLoad(velIn, pos + vec3<i32>( 0,-1,0), 0).y;
            let T = textureLoad(velIn, pos + vec3<i32>( 0, 1,0), 0).y;
            let Back = textureLoad(velIn, pos + vec3<i32>(0,0,-1), 0).z;
            let Front = textureLoad(velIn, pos + vec3<i32>(0,0, 1), 0).z;
            textureStore(div, pos, vec4<f32>(0.5 * (R - L + T - B + Front - Back), 0.0, 0.0, 0.0));
        }

        // --- Pressure ---
        @compute @workgroup_size(8, 4, 4)
        fn presMain(@builtin(global_invocation_id) id: vec3<u32>) {
            if (any(id >= vec3<u32>(u.res.xyz))) { return; }
            let pos = vec3<i32>(id);
            let obs = textureLoad(obsTex, pos, 0).r;
            if (obs > 0.5) { textureStore(presOut, pos, vec4<f32>(0.0)); return; }

            let d = textureLoad(divIn, pos, 0).r;
            let L = textureLoad(presIn, pos + vec3<i32>(-1,0,0), 0).r;
            let R = textureLoad(presIn, pos + vec3<i32>( 1,0,0), 0).r;
            let B = textureLoad(presIn, pos + vec3<i32>( 0,-1,0), 0).r;
            let T = textureLoad(presIn, pos + vec3<i32>( 0, 1,0), 0).r;
            let Back = textureLoad(presIn, pos + vec3<i32>(0,0,-1), 0).r;
            let Front = textureLoad(presIn, pos + vec3<i32>(0,0, 1), 0).r;

            let p = (L + R + B + T + Back + Front - d) / 6.0;
            textureStore(presOut, pos, vec4<f32>(p, 0.0, 0.0, 0.0));
        }

        // --- Subtract ---
        @compute @workgroup_size(8, 4, 4)
        fn subMain(@builtin(global_invocation_id) id: vec3<u32>) {
            if (any(id >= vec3<u32>(u.res.xyz))) { return; }
            let pos = vec3<i32>(id);
            let obs = textureLoad(obsTex, pos, 0).r;
            if (obs > 0.5) { textureStore(velOut, pos, vec4<f32>(0.0)); return; }

            let L = textureLoad(presIn, pos + vec3<i32>(-1,0,0), 0).r;
            let R = textureLoad(presIn, pos + vec3<i32>( 1,0,0), 0).r;
            let B = textureLoad(presIn, pos + vec3<i32>( 0,-1,0), 0).r;
            let T = textureLoad(presIn, pos + vec3<i32>( 0, 1,0), 0).r;
            let Back = textureLoad(presIn, pos + vec3<i32>(0,0,-1), 0).r;
            let Front = textureLoad(presIn, pos + vec3<i32>(0,0, 1), 0).r;

            let v = textureLoad(velIn, pos, 0).xyz;
            let grad = vec3<f32>(R-L, T-B, Front-Back) * 0.5;

            // SAFETY CLAMP again
            let finalV = v - grad;
            if (length(finalV) > 4.0) { textureStore(velOut, pos, vec4<f32>(normalize(finalV)*4.0, 0.0)); }
            else { textureStore(velOut, pos, vec4<f32>(finalV, 0.0)); }
        }

        // --- Render ---
        struct VSOut { @builtin(position) pos: vec4<f32>, @location(0) uv: vec2<f32> };
        @vertex fn vsMain(@builtin(vertex_index) idx: u32) -> VSOut {
            var p = array<vec2<f32>,3>(vec2<f32>(-1.0,-3.0), vec2<f32>(3.0,1.0), vec2<f32>(-1.0,1.0));
            var out: VSOut; out.pos = vec4<f32>(p[idx], 0.0, 1.0); out.uv = p[idx]; return out;
        }

        fn rayBoxIntersect(ro: vec3<f32>, rd: vec3<f32>, bMin: vec3<f32>, bMax: vec3<f32>) -> vec2<f32> {
            let t1 = (bMin - ro) / rd; let t2 = (bMax - ro) / rd;
            let tMin = min(t1, t2); let tMax = max(t1, t2);
            let tN = max(max(tMin.x, tMin.y), tMin.z); let tF = min(min(tMax.x, tMax.y), tMax.z);
            if (tN > tF || tF < 0.0) { return vec2<f32>(-1.0); }
            return vec2<f32>(tN, tF);
        }

        @fragment fn fsMain(in: VSOut) -> @location(0) vec4<f32> {
            let ro = u.camPos.xyz;
            let screenPos = vec4<f32>(in.uv.x, -in.uv.y, 1.0, 1.0);
            let worldPos = u.invViewProj * screenPos;
            let rd = normalize(worldPos.xyz / worldPos.w - ro);

            let boxSize = vec3<f32>(1.0, 0.375, 0.375);
            let t = rayBoxIntersect(ro, rd, vec3<f32>(0.0), boxSize);

            if (t.x < 0.0) { return vec4<f32>(0.02, 0.02, 0.03, 1.0); }

            var tCurr = max(0.0, t.x);
            let tEnd = t.y;
            let stepSz = 0.005;

            var accColor = vec3<f32>(0.0);
            var accAlpha = 0.0;
            let dims = vec3<f32>(u.res.xyz);

            let glowThresh = -u.params.w;

            for(var i=0; i<200; i++) {
                if(tCurr > tEnd || accAlpha > 0.98) { break; }
                let p = ro + rd * tCurr;
                let uv = p / boxSize;

                let den = textureSampleLevel(denIn, samplerLin, uv, 0.0).r;
                let obs = textureSampleLevel(obsTex, samplerLin, uv, 0.0).r;

                let iPos = vec3<i32>(floor(uv * dims));
                let cPos = clamp(iPos, vec3<i32>(0), vec3<i32>(dims) - vec3<i32>(1));
                let pres = textureLoad(presIn, cPos, 0).r;

                if (obs > 0.5) {
                    accColor = mix(accColor, vec3<f32>(0.15, 0.15, 0.2), 1.0 - accAlpha);
                    accAlpha = 1.0;
                    break;
                }

                // Smoke
                if (den > 0.01) {
                    let srcA = den * 0.5;
                    let srcCol = vec3<f32>(0.0, 0.8, 1.0);
                    accColor += srcCol * srcA * 0.1 * (1.0 - accAlpha);
                    accAlpha += srcA * 0.05;
                }

                // Suction
                if (pres < glowThresh) {
                    let intensity = clamp(abs(pres) * 10.0, 0.0, 1.5);
                    let col = vec3<f32>(1.0, 0.0, 1.0);
                    accColor += col * intensity * 0.15 * (1.0 - accAlpha);
                    accAlpha += intensity * 0.03;
                }
                tCurr += stepSz;
            }
            accColor = pow(accColor, vec3<f32>(0.8));
            return vec4<f32>(accColor + vec3<f32>(0.02), 1.0);
        }
        `;

        // Gizmo Draw Function
        function drawGizmo(viewMat) {
            const canvas = document.getElementById('gizmo');
            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;
            const cx = w / 2;
            const cy = h / 2;
            const size = 35;

            ctx.clearRect(0, 0, w, h);

            // Axes definitions (Right-Handed Y-up)
            const axes = [
                { vec: [1, 0, 0], color: '#ff3333', label: 'X' },
                { vec: [0, 1, 0], color: '#33ff33', label: 'Y' },
                { vec: [0, 0, 1], color: '#3333ff', label: 'Z' }
            ];

            // Project axes using view rotation
            const transformedAxes = axes.map(axis => {
                const x = axis.vec[0] * viewMat[0] + axis.vec[1] * viewMat[4] + axis.vec[2] * viewMat[8];
                const y = axis.vec[0] * viewMat[1] + axis.vec[1] * viewMat[5] + axis.vec[2] * viewMat[9];
                const z = axis.vec[0] * viewMat[2] + axis.vec[1] * viewMat[6] + axis.vec[2] * viewMat[10];
                return { ...axis, x, y, z };
            });

            // Sort by Z (draw back to front)
            transformedAxes.sort((a, b) => a.z - b.z);

            ctx.lineWidth = 2;
            ctx.font = 'bold 12px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            // Center Point
            ctx.beginPath();
            ctx.arc(cx, cy, 3, 0, Math.PI * 2);
            ctx.fillStyle = '#fff';
            ctx.fill();

            transformedAxes.forEach(axis => {
                const dx = axis.x * size;
                const dy = -axis.y * size; // Invert Y for Canvas

                ctx.beginPath();
                ctx.moveTo(cx, cy);
                ctx.lineTo(cx + dx, cy + dy);
                ctx.strokeStyle = axis.color;
                ctx.stroke();

                const textX = cx + dx * 1.3;
                const textY = cy + dy * 1.3;
                ctx.fillStyle = axis.color;
                ctx.fillText(axis.label, textX, textY);
            });
        }

        async function init() {
            if (!navigator.gpu) { alert("WebGPU not supported"); return; }
            const adapter = await navigator.gpu.requestAdapter();
            const device = await adapter.requestDevice();
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('webgpu');
            const format = navigator.gpu.getPreferredCanvasFormat();
            ctx.configure({ device, format, alphaMode: 'opaque' });

            const createTex3D = (fmt, usage) => device.createTexture({
                dimension: '3d', size: SIZE, format: fmt,
                usage: usage | GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST
            });

            const vel0 = createTex3D('rgba16float', GPUTextureUsage.STORAGE_BINDING);
            const vel1 = createTex3D('rgba16float', GPUTextureUsage.STORAGE_BINDING);
            const den0 = createTex3D('rgba16float', GPUTextureUsage.STORAGE_BINDING);
            const den1 = createTex3D('rgba16float', GPUTextureUsage.STORAGE_BINDING);
            const pres0 = createTex3D('r32float', GPUTextureUsage.STORAGE_BINDING);
            const pres1 = createTex3D('r32float', GPUTextureUsage.STORAGE_BINDING);
            const div = createTex3D('r32float', GPUTextureUsage.STORAGE_BINDING);
            const obs = createTex3D('r16float', 0);

            // --- IMPROVED SDF Setup ---
            const updateModel = (xShift = -1.0, drs = false) => {
                const [W,H,D] = SIZE;
                const data = new Float32Array(W*H*D);
                const length2 = (x,y) => Math.sqrt(x*x + y*y);

                for(let z=0; z<D; z++) {
                    for(let y=0; y<H; y++) {
                        for(let x=0; x<W; x++) {
                            let px = x/W; let py = y/H; let pz = z/D;
                            let cx_world = (px-0.5)*2.0;
                            let cy = (py-0.5)*2.0;
                            let cz = (pz-0.5)*2.0;

                            // User shift and scale
                            // xShift = -1.0 means more to the left
                            let cx = (cx_world - xShift) * 2.2;
                            let cy_l = cy * 1.4;
                            let cz_l = cz * 1.4;

                            // 1. Central Body
                            let width = 0.5 * (1.0 - Math.max(0, -cx*0.3));
                            let body = Math.max(Math.abs(cx)-0.6, Math.abs(cy_l)-0.12, Math.abs(cz_l)-width*0.3);

                            // 2. Nose Cone (Low - Positive cy)
                            // Positive cy is DOWN in our inverted logic? No, we fixed logic in SDF
                            // Let's re-verify:
                            // Ground is at Y+0.38
                            // Nose should be slightly above ground
                            // So Nose Y should be around +0.2
                            let nose = Math.max(Math.abs(cx+0.7)-0.2, length2(cy_l-0.2, cz_l) - 0.08 * (1.0 - (cx+0.5)));

                            // 3. Sidepods (Middle-Low)
                            let spBox = Math.max(Math.abs(cx)-0.3, Math.abs(cy_l-0.05)-0.12, Math.abs(cz_l)-0.4);
                            let undercut = length2(cy_l - 0.15, Math.abs(cz_l) - 0.5) - 0.2;
                            let sidepod = Math.max(spBox, -undercut);

                            // 4. Floor (Lowest - Most Positive cy)
                            // Ground at ~0.38
                            let floorPlate = Math.max(Math.abs(cx)-0.65, Math.abs(cy_l-0.35)-0.015, Math.abs(cz_l)-0.45);

                            // 5. Wheels (Lowest)
                            // Center at +0.25 cy
                            let wheelDistF = Math.sqrt((cx+0.4)**2 + (cy_l-0.25)**2);
                            let wheelDistR = Math.sqrt((cx-0.45)**2 + (cy_l-0.25)**2);
                            let wheelF = Math.max(wheelDistF-0.13, Math.abs(Math.abs(cz_l)-0.5)-0.06);
                            let wheelR = Math.max(wheelDistR-0.14, Math.abs(Math.abs(cz_l)-0.5)-0.07);

                            // 6. Halo (High - Negative cy)
                            // Above body (cy=0) -> negative
                            let haloStrut = Math.max(Math.abs(cx+0.1)-0.01, Math.abs(cy_l+0.2)-0.08, Math.abs(cz_l)-0.01);
                            let haloHoop = Math.max(Math.abs(cx)-0.1, length2(cy_l+0.15, Math.abs(cz_l)-0.15) - 0.02);

                            // 7. Wings
                            // Front Wing (Lowest - Positive cy)
                            let fWing = Math.max(Math.abs(cx+0.9)-0.05, Math.abs(cy_l-0.35)-0.02, Math.abs(cz_l)-0.5);

                            // Rear Wing (Highest - Negative cy)
                            let zWidth = 0.55;
                            // Main Plane (Lower, always there)
                            // Y Position: -0.45 (High)
                            let rwMain = Math.max(Math.abs(cx-0.75)-0.12, Math.abs(cy_l+0.45)-0.03, Math.abs(cz_l)-zWidth);

                            // Flap (Upper, disappears on DRS)
                            // Y Position: -0.58 (Higher)
                            let rwFlap = Math.max(Math.abs(cx-0.82)-0.06, Math.abs(cy_l+0.58)-0.03, Math.abs(cz_l)-zWidth);

                            let rWing;
                            if (drs) {
                                // DRS ON: Only Main Plane remains
                                rWing = rwMain;
                            } else {
                                // DRS OFF: 2 Elements (Main + Flap)
                                rWing = Math.min(rwMain, rwFlap);
                            }

                            let car = Math.min(body, nose, sidepod, floorPlate, wheelF, wheelR, fWing, rWing, haloStrut, haloHoop);

                            data[z*H*W + y*W + x] = car < 0 ? 1.0 : 0.0;
                        }
                    }
                }
                device.queue.writeTexture({ texture: obs }, data, { bytesPerRow: W * 4, rowsPerImage: H }, SIZE);
            };

            // Initial Model Update
            updateModel(-1.0, false);

            const smp = device.createSampler({ magFilter: 'linear', minFilter: 'linear' });
            const mod = device.createShaderModule({ code: shaderCode });
            const pipe = (entry) => device.createComputePipeline({ layout: 'auto', compute: { module: mod, entryPoint: entry }});

            const pAdvect = pipe('advectMain');
            const pForce = pipe('forceMain');
            const pDiv = pipe('divMain');
            const pPres = pipe('presMain');
            const pSub = pipe('subMain');

            const renderPipe = device.createRenderPipeline({
                layout: 'auto', vertex: { module: mod, entryPoint: 'vsMain' },
                fragment: { module: mod, entryPoint: 'fsMain', targets: [{ format }] },
                primitive: { topology: 'triangle-list' }
            });

            const uBuf = device.createBuffer({ size: 176, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
            const bind = (p, ents) => device.createBindGroup({ layout: p.getBindGroupLayout(0), entries: ents });

            // --- Params & UI ---
            const params = {
                // USER TUNED VALUES (Golden Ratio)
                substeps: 30, // Increased for efficiency mode
                dt: 0.005,
                speed: 1.6,
                decay: 0.998,
                glow: 0.001,
                pos: -1.0,
                drs: false,
                reset: false
            };

            const bindRange = (id, key, disp) => {
                const el = document.getElementById(id);
                el.value = params[key]; // Set init value
                document.getElementById(disp).innerText = params[key];

                el.addEventListener('input', e => {
                    params[key] = parseFloat(e.target.value);
                    document.getElementById(disp).innerText = params[key];
                });
            };
            bindRange('p_speed', 'speed', 'v_speed');
            bindRange('p_dt', 'dt', 'v_dt');
            bindRange('p_decay', 'decay', 'v_decay');
            bindRange('p_glow', 'glow', 'v_glow');
            bindRange('p_sub', 'substeps', 'v_sub');
            bindRange('p_pos', 'pos', 'v_pos');

            // DRS Button
            const drsBtn = document.getElementById('btn_drs');
            drsBtn.addEventListener('click', () => {
                params.drs = !params.drs;
                drsBtn.innerText = params.drs ? "DRS: OPEN" : "DRS: CLOSED";
                drsBtn.classList.toggle('active', params.drs);
                updateModel(params.pos, params.drs);
            });

            document.getElementById('btn_reset').addEventListener('click', () => {
                params.reset = true;
                updateModel(params.pos, params.drs);
            });

            // --- Orbit Camera ---
            const cam = {
                rotX: 2.5, rotY: 0.4, dist: 2.5,
                target: [0.5, 0.25, 0.25], // Center of Sim Box
                pos: [0,0,0]
            };

            canvas.addEventListener('mousemove', e => {
                if(e.buttons === 1){ // Left Drag: Rotate
                    cam.rotX -= e.movementX * 0.01;
                    cam.rotY -= e.movementY * 0.01;
                    cam.rotY = Math.max(-1.5, Math.min(1.5, cam.rotY));
                }
                if(e.buttons === 2){ // Right Drag: Pan Target
                    const speed = 0.002 * cam.dist;
                    cam.target[0] -= Math.cos(cam.rotX) * e.movementX * speed;
                    cam.target[2] -= Math.sin(cam.rotX) * e.movementX * speed;
                    cam.target[1] += e.movementY * speed;
                }
            });
            canvas.addEventListener('wheel', e => {
                cam.dist += e.deltaY * 0.002;
                cam.dist = Math.max(0.1, cam.dist);
                e.preventDefault();
            }, {passive:false});
            canvas.addEventListener('contextmenu', e => e.preventDefault());

            // --- Keyboard Controls (WASD+QE) ---
            const keys = { w:0, a:0, s:0, d:0, q:0, e:0, shift:0 };
            window.addEventListener('keydown', e => {
                const k = e.key.toLowerCase();
                if(keys.hasOwnProperty(k)) keys[k] = 1;
                if(e.shiftKey) keys.shift = 1;
            });
            window.addEventListener('keyup', e => {
                const k = e.key.toLowerCase();
                if(keys.hasOwnProperty(k)) keys[k] = 0;
                keys.shift = !!e.shiftKey;
            });

            let vIn = vel0, vOut = vel1, dIn = den0, dOut = den1, pIn = pres0, pOut = pres1;

            const proj = Mat4.create();
            const view = Mat4.create();
            const vp = Mat4.create();
            const invVp = Mat4.create();

            // Clear Texture Helper
            const clearTex = (tex) => {
                const z = new Float32Array(SIZE[0]*SIZE[1]*SIZE[2]*4); // Zero
                device.queue.writeTexture({ texture: tex }, z, { bytesPerRow: SIZE[0]*16, rowsPerImage: SIZE[1] }, SIZE);
            };

            function frame() {
                if (params.reset) {
                    clearTex(vel0); clearTex(vel1);
                    clearTex(den0); clearTex(den1);
                    clearTex(pres0); clearTex(pres1);
                    clearTex(div);
                    params.reset = false;
                }

                canvas.width = window.innerWidth; canvas.height = window.innerHeight;

                // Update Target Position (WASD)
                const speed = 0.01 * (keys.shift ? 3 : 1) * cam.dist;
                const yaw = cam.rotX;
                const fwd = [Math.sin(yaw), 0, Math.cos(yaw)];
                const right = [Math.cos(yaw), 0, -Math.sin(yaw)];

                if (keys.w) { cam.target[0] -= fwd[0]*speed; cam.target[2] -= fwd[2]*speed; }
                if (keys.s) { cam.target[0] += fwd[0]*speed; cam.target[2] += fwd[2]*speed; }
                if (keys.a) { cam.target[0] -= right[0]*speed; cam.target[2] -= right[2]*speed; }
                if (keys.d) { cam.target[0] += right[0]*speed; cam.target[2] += right[2]*speed; }
                if (keys.q) { cam.target[1] += speed; } // Up (Unity Q)
                if (keys.e) { cam.target[1] -= speed; } // Down (Unity E)

                // Calculate Camera Position
                const cx = cam.target[0] + Math.sin(cam.rotX) * Math.cos(cam.rotY) * cam.dist;
                const cy = cam.target[1] + Math.sin(cam.rotY) * cam.dist;
                const cz = cam.target[2] + Math.cos(cam.rotX) * Math.cos(cam.rotY) * cam.dist;

                Mat4.lookAt(view, [cx, cy, cz], cam.target, [0,1,0]);
                Mat4.perspective(proj, Math.PI/3, canvas.width/canvas.height, 0.1, 100.0);
                Mat4.multiply(vp, proj, view);
                Mat4.invert(invVp, vp);

                // Draw Gizmo
                drawGizmo(view);

                const uData = new Float32Array(44);
                uData.set([SIZE[0], SIZE[1], SIZE[2], 0], 0);
                uData.set([params.speed, params.dt, params.decay, params.glow], 4);
                uData.set([cx, cy, cz, performance.now()/1000], 8);
                uData.set(vp, 12);
                uData.set(invVp, 28);
                device.queue.writeBuffer(uBuf, 0, uData);

                const enc = device.createCommandEncoder();
                const runPass = (p, bG) => {
                     const pass = enc.beginComputePass(); pass.setPipeline(p); pass.setBindGroup(0, bG);
                     pass.dispatchWorkgroups(SIZE[0]/WORKGROUP[0], SIZE[1]/WORKGROUP[1], SIZE[2]/WORKGROUP[2]); pass.end();
                };

                // --- SUBSTEPS LOOP ---
                for(let s=0; s<params.substeps; s++) {
                    // Advect
                    runPass(pAdvect, bind(pAdvect, [
                        { binding: 0, resource: { buffer: uBuf } },
                        { binding: 1, resource: vIn.createView() }, { binding: 2, resource: vOut.createView() },
                        { binding: 3, resource: dIn.createView() }, { binding: 4, resource: dOut.createView() },
                        { binding: 9, resource: smp }, { binding: 10, resource: obs.createView() }
                    ]));
                    [vIn, vOut] = [vOut, vIn]; [dIn, dOut] = [dOut, dIn];

                    // Force
                    runPass(pForce, bind(pForce, [
                        { binding: 0, resource: { buffer: uBuf } },
                        { binding: 1, resource: vIn.createView() }, { binding: 2, resource: vOut.createView() },
                        { binding: 3, resource: dIn.createView() }, { binding: 4, resource: dOut.createView() },
                        { binding: 10, resource: obs.createView() }
                    ]));
                    [vIn, vOut] = [vOut, vIn]; [dIn, dOut] = [dOut, dIn];

                    // Div
                    runPass(pDiv, bind(pDiv, [
                        { binding: 0, resource: { buffer: uBuf } },
                        { binding: 1, resource: vIn.createView() }, { binding: 7, resource: div.createView() }
                    ]));

                    // Pres (8 iterations)
                    for(let i=0; i<8; i++) {
                        runPass(pPres, bind(pPres, [
                            { binding: 0, resource: { buffer: uBuf } },
                            { binding: 8, resource: div.createView() },
                            { binding: 5, resource: pIn.createView() }, { binding: 6, resource: pOut.createView() },
                            { binding: 10, resource: obs.createView() }
                        ]));
                        [pIn, pOut] = [pOut, pIn];
                    }

                    // Sub
                    runPass(pSub, bind(pSub, [
                        { binding: 0, resource: { buffer: uBuf } },
                        { binding: 1, resource: vIn.createView() },
                        { binding: 5, resource: pIn.createView() },
                        { binding: 2, resource: vOut.createView() },
                        { binding: 10, resource: obs.createView() }
                    ]));
                    [vIn, vOut] = [vOut, vIn];
                }

                // Render
                {
                    const pass = enc.beginRenderPass({ colorAttachments: [{ view: ctx.getCurrentTexture().createView(), loadOp: 'clear', clearValue: {r:0,g:0,b:0,a:1}, storeOp: 'store' }] });
                    pass.setPipeline(renderPipe);
                    pass.setBindGroup(0, bind(renderPipe, [
                        { binding: 0, resource: { buffer: uBuf } },
                        { binding: 3, resource: dIn.createView() },
                        { binding: 9, resource: smp },
                        { binding: 10, resource: obs.createView() },
                        { binding: 5, resource: pIn.createView() }
                    ]));
                    pass.draw(3);
                    pass.end();
                }

                device.queue.submit([enc.finish()]);
                requestAnimationFrame(frame);
            }
            requestAnimationFrame(frame);
        }
        init();
    </script>
</body>
</html>
